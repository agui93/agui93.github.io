- 目录
{:toc #markdown-toc}	


## Java并发机制的底层实现原理     
Java中所使用的并发机制依赖于JVM的实现和
CPU的指令    

### volatile

可见性:当一个线程修改一个共享变量时，另一个线程能读到这个修改的值。    
    
volatile在多处理器开发中保证了共享变量的可见性，不会引起线程上下文的切换和调度，是轻量级的synchronized。

析在硬件层面上Intel处理器是如何实现volatile的？     

**volatile的定义与实现原理**       
如果一个字段被声明成volatile，Java线程内存模型确保所有线程看到这个变量的值是一致的。

volatile是如何来保证可见性的呢？  
    
为了提高处理速度，处理器不直接和内存进行通信，而是先将系统内存的数据读到内部
缓存（L1，L2或其他）后再进行操作，但操作完不知道何时会写到内存。        
如果对声明了volatile的变量进行写操作，JVM就会向处理器发送一条Lock前缀的指令，将这个变量所在缓存行的数据写回到系统内存。         
但是，就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题。         
所以，在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存
里。


**volatile的使用优化**       
Doug lea在JDK7的并发包里新增一个队列集合类LinkedTransferQueue，它在使用volatile变量时，用一种追加字节的方式来优化队列出队和入队的性能。

为什么追加64字节能够提高并发编程的效率呢？

那么是不是在使用volatile变量时都应该追加到64字节呢？


